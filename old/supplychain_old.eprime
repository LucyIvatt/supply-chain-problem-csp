language ESSENCE' 1.0

given nShops: int(1..)

given demands : matrix indexed by [int(1..nShops)] of int(1..)
given packageSize : matrix indexed by [int(1..nSuppliers)] of int(1..) $ assuming no empty packages
given packageCost : matrix indexed by [int(1..nSuppliers)] of int(1..) $ in case packages can be free

given excessStockLimit: int(0..)

given nSuppliers: int(1..)

letting maxOrderNum be max(demands) / min(packageSize)

find allocations: matrix indexed by [int(1..nShops), int(1..nSuppliers)] of int(0..maxOrderNum)

minimising(
    sum([
        allocations[shop, supplier] * packageCost[supplier] | shop : int(1..nShops), supplier: int(1..nSuppliers)
    ])
)

$ CONSTRAINTS
such that

forAll shop: int(1..nShops) .
    sum([allocations[shop, supplier]*packageSize[supplier] | supplier: int(1..nSuppliers)]) >= demands[shop],

forAll shop: int(1..nShops) .
    sum([allocations[shop, supplier]*packageSize[supplier] | supplier: int(1..nSuppliers)]) <= demands[shop] + excessStockLimit

